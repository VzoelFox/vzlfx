; utils/format/asm_writer.asm
; [AI_HINT: Generate FASM-compatible assembly text from machine code]
; Code Honesty: Output is auditable assembly text

seer.format.asm_write:
    ; Input:
    ;   rdi = output filename (null-terminated string)
    ;   rsi = code buffer pointer
    ;   rdx = code size
    ; Output:
    ;   rax = 0 (success) or error code

    push rbp
    mov rbp, rsp
    push r12
    push r13
    push r14
    push r15
    push rbx

    ; Save inputs
    mov r12, rdi        ; filename
    mov r13, rsi        ; code buffer
    mov r14, rdx        ; code size

    ; Open output file
    mov rdi, r12
    mov rsi, 0x241      ; O_CREAT | O_TRUNC | O_WRONLY
    mov rdx, 0644o
    mov rax, 2          ; sys_open
    syscall

    cmp rax, 0
    jl .error
    mov r15, rax        ; r15 = fd

    ; Write header
    mov rdi, r15
    lea rsi, [.header]
    mov rdx, .header_end - .header
    mov rax, 1
    syscall

    ; Write code bytes as db statements
    xor rbx, rbx        ; rbx = index

.write_loop:
    cmp rbx, r14
    jge .write_footer

    ; Write "    db "
    mov rdi, r15
    lea rsi, [.db_prefix]
    mov rdx, 7
    mov rax, 1
    syscall

    ; Convert byte to hex and write
    movzx rax, byte [r13 + rbx]

    ; Write "0x"
    mov rdi, r15
    lea rsi, [.hex_prefix]
    mov rdx, 2
    push rax
    mov rax, 1
    syscall
    pop rax

    ; Convert to hex string (2 chars)
    push rax
    shr rax, 4          ; High nibble
    call .write_hex_digit
    pop rax
    and rax, 0x0F       ; Low nibble
    call .write_hex_digit

    ; Write newline
    mov rdi, r15
    lea rsi, [.newline]
    mov rdx, 1
    mov rax, 1
    syscall

    inc rbx
    jmp .write_loop

.write_footer:
    ; Write footer
    mov rdi, r15
    lea rsi, [.footer]
    mov rdx, .footer_end - .footer
    mov rax, 1
    syscall

    ; Close file
    mov rdi, r15
    mov rax, 3
    syscall

    xor rax, rax
    jmp .done

.write_hex_digit:
    ; Input: rax = digit (0-15)
    ; Write single hex digit to fd r15
    cmp rax, 9
    jle .is_digit
    add rax, 'A' - 10
    jmp .write_char
.is_digit:
    add rax, '0'
.write_char:
    push rax
    mov rdi, r15
    mov rsi, rsp
    mov rdx, 1
    push rax            ; Save for later pop
    mov rax, 1
    syscall
    pop rax
    pop rax
    ret

.error:
    mov rax, -1

.done:
    pop rbx
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbp
    ret

.header:
    db "; Generated by Morph Compiler", 10
    db "; Target: Linux x86-64 ELF64", 10, 10
    db "format ELF64 executable 3", 10
    db "segment readable executable", 10
    db "entry start", 10, 10
    db "start:", 10
.header_end:

.db_prefix: db "    db "
.hex_prefix: db "0x"
.newline: db 10

.footer:
    db 10
    db "; End of generated code", 10
.footer_end:
