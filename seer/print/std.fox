; Morph Seer Print (Standard Output)
; [AI_HINT: Wrapper jujur untuk output standar tanpa magic formatting]
; Dependency: Brainlib/kernel.vzoel, Brainlib/memori.vzoel

; --- String Output ---

seer.print.raw      kind=macro action={
    ; [AI_HINT: Cetak buffer raw (bytes) ke stdout]
    ; Input: rdi (buffer), rsi (len)

    push rdx
    push rax

    mov rdx, rsi    ; Panjang ke RDX
    mov rsi, rdi    ; Buffer ke RSI
    mov rdi, 1      ; STDOUT ke RDI

    ; Panggil syscall write langsung dari kernel
    ; Kita gunakan definisi macro sys.fs.write tapi karena ini macro dalam macro,
    ; kita tulis manual instruksinya untuk transparansi penuh.
    mov rax, 1      ; sys_write
    syscall

    pop rax
    pop rdx
}

; Implementasi ulang puts dengan flow yang lebih bersih
seer.print.text     kind=macro action={
    ; [AI_HINT: Cetak string null-terminated sederhana]
    ; Input: rdi (pointer string)

    push rdi
    push rsi
    push rcx
    push rdx
    push rax

    mov rsi, rdi    ; Simpan pointer awal di RSI (untuk syscall nanti)

    ; Hitung panjang
    xor rcx, rcx    ; Counter = 0

    .loop_len:
        cmp byte [rdi], 0   ; Cek null
        je .done_len
        inc rdi
        inc rcx
        jmp .loop_len
    .done_len:

    ; Sekarang: RSI = buffer, RCX = panjang
    mov rdx, rcx    ; Panjang ke RDX
    mov rdi, 1      ; STDOUT ke RDI
    mov rax, 1      ; SYS_WRITE
    syscall

    pop rax
    pop rdx
    pop rcx
    pop rsi
    pop rdi
}

; --- New Line ---

seer.print.nl       kind=macro action={
    ; [AI_HINT: Cetak baris baru (\n)]
    push rdi
    push rsi
    push rdx
    push rax

    ; Trik stack: dorong \n (0x0A) ke stack dan cetak dari sana
    push 0x0A       ; Push 10 (newline)
    mov rsi, rsp    ; RSI menunjuk ke stack
    mov rdx, 1      ; Panjang 1 byte
    mov rdi, 1      ; STDOUT
    mov rax, 1      ; SYS_WRITE
    syscall

    pop rax         ; Bersihkan 0x0A dari stack (ke RAX sementara)

    pop rax
    pop rdx
    pop rsi
    pop rdi
}

; --- Integer Output (Decimal) ---

seer.print.int      kind=macro action={
    ; [AI_HINT: Cetak integer 64-bit (signed) ke stdout]
    ; Input: rdi (integer value)

    push rdi
    push rsi
    push rdx
    push rcx
    push rax
    push r8
    push rbp
    mov rbp, rsp

    ; Buffer lokal di stack (20 byte cukup untuk 64-bit int)
    sub rsp, 24
    mov r8, rsp     ; r8 menunjuk ke buffer start
    add r8, 20      ; Mulai dari belakang buffer
    mov byte [r8], 0 ; Null terminator (opsional, kita pakai length)

    mov rax, rdi    ; Nilai yang akan dibagi
    mov rcx, 10     ; Pembagi
    xor rsi, rsi    ; Counter digit

    ; Handle tanda negatif
    cmp rax, 0
    jge .process_digit
    neg rax         ; Jadikan positif
    ; (Kita ingat negatif nanti, atau cetak '-' dulu? Cetak '-' langsung aja simple)
    push rax
    push rdi
    push rsi
    push rdx

    mov rdi, "-"    ; TODO: Ini harus pointer ke string "-", anggap compiler handle literal
    ; call seer.print.text ; (Jangan panggil macro dalam macro dulu jika belum stabil, manual write aja)
    ; Manual write '-' char
    push 0x2D       ; '-'
    mov rsi, rsp
    mov rdx, 1
    mov rdi, 1
    mov rax, 1
    syscall
    pop rax         ; clean stack

    pop rdx
    pop rsi
    pop rdi
    pop rax

    .process_digit:
        xor rdx, rdx    ; Clear sisa bagi
        div rcx         ; rax / 10 -> rax=quotient, rdx=remainder

        add dl, '0'     ; Convert ke ASCII
        dec r8          ; Mundur pointer buffer
        mov [r8], dl    ; Simpan digit
        inc rsi         ; Tambah panjang

        test rax, rax   ; Cek jika habis
        jnz .process_digit

    ; Cetak buffer
    mov rdx, rsi    ; Panjang
    mov rsi, r8     ; Pointer buffer (posisi terakhir)
    mov rdi, 1      ; Stdout
    mov rax, 1      ; Syscall Write
    syscall

    mov rsp, rbp    ; Restore stack lokal
    pop rbp
    pop r8
    pop rax
    pop rcx
    pop rdx
    pop rsi
    pop rdi
}

; --- Hex Output ---

seer.print.hex      kind=macro action={
    ; [AI_HINT: Cetak integer 64-bit dalam format Hex (0x...)]
    ; Input: rdi (integer value)

    push rdi
    push rsi
    push rdx
    push rcx
    push rax
    push rbp
    mov rbp, rsp

    ; Cetak "0x" prefix
    push 0x7830     ; "0x" (Little Endian: '0' low, 'x' high? No, '0'=0x30, 'x'=0x78)
                    ; Memory: 0x30, 0x78. Reg: 0x7830.
    mov rsi, rsp
    mov rdx, 2
    mov rdi, 1
    mov rax, 1
    syscall
    pop rax         ; Clean "0x"

    ; Buffer 16 digit
    sub rsp, 16
    mov rsi, rsp    ; Pointer buffer
    add rsi, 16     ; Mulai dari ujung

    mov rax, [rbp+40] ; Ambil RDI asli (dari push rdi paling atas... wait offsetnya 40?
                      ; push: rdi(8), rsi(8), rdx(8), rcx(8), rax(8), rbp(8) -> total 48.
                      ; [rbp] = saved rbp. [rbp+8] = ret addr (jika call).
                      ; Tapi ini macro, jadi inline. Stack lurus.
                      ; rdi ada di [rbp+40] (8*5 = 40).
                      ; TUNGGU: rdi ada di stack paling bawah sebelum rbp.
                      ; Urutan push: rdi, rsi, rdx, rcx, rax, rbp.
                      ; rbp -> saved rbp
                      ; rbp+8 -> saved rax
                      ; rbp+16 -> saved rcx
                      ; rbp+24 -> saved rdx
                      ; rbp+32 -> saved rsi
                      ; rbp+40 -> saved rdi. Correct.

    mov rax, [rbp+40]
    mov rcx, 16     ; 16 digit hex

    .hex_loop:
        dec rsi
        mov rdx, rax
        and rdx, 0xF    ; Ambil 4 bit terakhir

        cmp dl, 9
        jg .hex_alpha
        add dl, '0'
        jmp .hex_store

    .hex_alpha:
        add dl, 'A'-10

    .hex_store:
        mov [rsi], dl
        shr rax, 4      ; Geser
        dec rcx
        jnz .hex_loop

    ; Cetak 16 digit
    mov rdx, 16
    ; rsi sudah di awal buffer
    mov rdi, 1
    mov rax, 1
    syscall

    mov rsp, rbp
    pop rbp
    pop rax
    pop rcx
    pop rdx
    pop rsi
    pop rdi
}
