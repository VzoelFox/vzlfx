; Morph Seer Print (Standard Output)
; [AI_HINT: Wrapper jujur untuk output standar tanpa magic formatting]
; Dependency: Brainlib/kernel.vzoel, Brainlib/memori.vzoel

; --- String Output ---

seer.print.raw      kind=macro action={
    ; [AI_HINT: Cetak buffer raw (bytes) ke stdout]
    ; Input: rdi (buffer), rsi (len)

    push rdx
    push rax

    mov rdx, rsi    ; Panjang ke RDX
    mov rsi, rdi    ; Buffer ke RSI
    mov rdi, 1      ; STDOUT ke RDI

    ; Panggil syscall write langsung dari kernel
    ; Kita gunakan definisi macro sys.fs.write tapi karena ini macro dalam macro,
    ; kita tulis manual instruksinya untuk transparansi penuh.
    mov rax, 1      ; sys_write
    syscall

    pop rax
    pop rdx
}

; Implementasi ulang puts dengan flow yang lebih bersih
seer.print.text     kind=macro action={
    ; [AI_HINT: Cetak string null-terminated sederhana]
    ; Input: rdi (pointer string)

    push rdi
    push rsi
    push rcx
    push rdx
    push rax

    mov rsi, rdi    ; Simpan pointer awal di RSI (untuk syscall nanti)

    ; Hitung panjang
    xor rcx, rcx    ; Counter = 0

    .loop_len:
        cmp byte [rdi], 0   ; Cek null
        je .done_len
        inc rdi
        inc rcx
        jmp .loop_len
    .done_len:

    ; Sekarang: RSI = buffer, RCX = panjang
    mov rdx, rcx    ; Panjang ke RDX
    mov rdi, 1      ; STDOUT ke RDI
    mov rax, 1      ; SYS_WRITE
    syscall

    pop rax
    pop rdx
    pop rcx
    pop rsi
    pop rdi
}

; --- New Line ---

seer.print.nl       kind=macro action={
    ; [AI_HINT: Cetak baris baru (\n)]
    push rdi
    push rsi
    push rdx
    push rax

    ; Trik stack: dorong \n (0x0A) ke stack dan cetak dari sana
    push 0x0A       ; Push 10 (newline)
    mov rsi, rsp    ; RSI menunjuk ke stack
    mov rdx, 1      ; Panjang 1 byte
    mov rdi, 1      ; STDOUT
    mov rax, 1      ; SYS_WRITE
    syscall

    pop rax         ; Bersihkan 0x0A dari stack (ke RAX sementara)

    pop rax
    pop rdx
    pop rsi
    pop rdi
}
