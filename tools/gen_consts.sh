#!/bin/bash
# tools/gen_consts.sh
# Generate FASM include file from Brainlib JSONs
# Usage: ./tools/gen_consts.sh > Brainlib/brainlib.inc

echo "; Generated by tools/gen_consts.sh"
echo "; Date: $(date)"

# Track defined labels to avoid duplicates
DEFINED_LABELS=" "

# Registry content buffer
REGISTRY_ENTRIES=""

# Function to process a single JSON file
process_file() {
    local filepath="$1"
    local filename=$(basename "$filepath")

    echo ""
    echo "; ----------------------------------------------------------------"
    echo "; From $filename"
    echo "; ----------------------------------------------------------------"

    local mnemonic=""
    local name=""
    local kind=""
    local value=""
    local hint=""
    local opcode=""
    local in_block=0

    # Read file line by line
    while IFS= read -r line; do
        # Strip whitespace
        line=$(echo "$line" | sed 's/^[ \t]*//;s/[ \t]*$//')

        if [[ "$line" == "{" ]]; then
            in_block=1
            mnemonic=""
            name=""
            kind=""
            value=""
            hint=""
            opcode=""
        elif [[ "$line" == "}," ]] || [[ "$line" == "}" ]]; then
            if [[ "$in_block" -eq 1 ]]; then
                # 1. Handle Terminal Constants
                if [[ "$filename" == "terminal.json" && "$kind" == "const_str" ]]; then
                    val_content="${value%\"}"
                    val_content="${val_content#\"}"
                    if [[ "$val_content" == *"\\u001b"* ]]; then
                        rest=${val_content/\\u001b/}
                        echo "str_${name} db 0x1b, '${rest}', 0"
                        echo "${name} equ str_${name}"
                    else
                        echo "str_${name} db '${val_content}', 0"
                        echo "${name} equ str_${name}"
                    fi
                fi

                # 2. Handle Instructions & Hints
                local key=""
                if [[ -n "$mnemonic" ]]; then
                    key="$mnemonic"
                elif [[ -n "$name" ]]; then
                    key="$name"
                fi

                if [[ -n "$key" ]]; then
                    local label_key=$(echo "$key" | tr '.' '_')
                    local hint_label="hint_${label_key}"
                    local str_label="str_${label_key}"
                    local op_label="op_${label_key}"
                    local len_label="len_${label_key}"

                    # Hint String
                    if [[ -n "$hint" ]]; then
                        local hint_content="${hint%\"}"
                        hint_content="${hint_content#\"}"

                        if [[ "$DEFINED_LABELS" != *" $hint_label "* ]]; then
                            echo "${hint_label} db '${hint_content}', 0"
                            DEFINED_LABELS+="$hint_label "
                        fi
                    fi

                    # Mnemonic String (for Tokenizer Lookup)
                    if [[ -n "$mnemonic" ]]; then
                         if [[ "$DEFINED_LABELS" != *" $str_label "* ]]; then
                            echo "${str_label} db '${mnemonic}', 0"
                            DEFINED_LABELS+="$str_label "
                        fi
                    fi

                    # Opcode Data
                    if [[ -n "$mnemonic" && -n "$opcode" ]]; then
                         # Calculate Opcode Length (count commas + 1)
                         # e.g. "0x0F,0xAF" -> 2
                         local op_len=$(echo "$opcode" | awk -F, '{print NF}')

                         if [[ "$DEFINED_LABELS" != *" $op_label "* ]]; then
                             echo "${op_label} db ${opcode}"
                             echo "${len_label} dq ${op_len}"
                             DEFINED_LABELS+="$op_label "

                             # Add to Registry Entry Buffer
                             # Format: [Ptr Mnemonic] [Ptr Opcode] [Len Opcode] [Ptr Hint]
                             # Use ${op_len} directly (value) instead of label (address)
                             REGISTRY_ENTRIES+="\n    dq ${str_label}\n    dq ${op_label}\n    dq ${op_len}\n    dq ${hint_label}"
                         fi
                    fi
                fi
            fi
            in_block=0
        else
            if [[ "$line" =~ \"mnemonic\":\ \"([^\"]+)\" ]]; then
                mnemonic="${BASH_REMATCH[1]}"
            elif [[ "$line" =~ \"name\":\ \"([^\"]+)\" ]]; then
                name="${BASH_REMATCH[1]}"
            elif [[ "$line" =~ \"kind\":\ \"([^\"]+)\" ]]; then
                kind="${BASH_REMATCH[1]}"
            elif [[ "$line" =~ \"value\":\ \"(.*)\" ]]; then
                value="\"${BASH_REMATCH[1]}\""
            elif [[ "$line" =~ \"hint\":\ \"(.*)\" ]]; then
                hint="\"${BASH_REMATCH[1]}\""
            elif [[ "$line" =~ \"opcode\":\ \"([^\"]+)\" ]]; then
                opcode="${BASH_REMATCH[1]}"
            fi
        fi
    done < "$filepath"
}

# Iterate over all JSON files
for f in $(ls Brainlib/*.json | sort); do
    process_file "$f"
done

# Output Registry
echo ""
echo "; ----------------------------------------------------------------"
echo "; Instruction Registry"
echo "; ----------------------------------------------------------------"
echo "instruction_registry:"
echo -e "$REGISTRY_ENTRIES"
echo "    dq 0 ; Terminator"
