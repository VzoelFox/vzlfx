; Morph Aritmatika (Arithmetic)

; Addition
add.r64.r64         rex=W opcode=0x01 modrm=reg,reg ; [AI_HINT: Tambah register dengan register (+)]
add.r64.mem         rex=W opcode=0x03 modrm=reg,mem ; [AI_HINT: Tambah register dengan memori (+)]
add.mem.r64         rex=W opcode=0x01 modrm=mem,reg ; [AI_HINT: Tambah memori dengan register (+)]
add.r64.imm32       rex=W opcode=0x81 modrm=0 imm32 ; [AI_HINT: Tambah register dengan angka 32-bit (+)]
add.mem.imm32       rex=W opcode=0x81 modrm=0 imm32 ; [AI_HINT: Tambah memori dengan angka 32-bit (+)]
add.r64.imm8        rex=W opcode=0x83 modrm=0 imm8  ; [AI_HINT: Tambah register dengan angka 8-bit (+)]
add.mem.imm8        rex=W opcode=0x83 modrm=0 imm8  ; [AI_HINT: Tambah memori dengan angka 8-bit (+)]

; Add with Carry (ZFC Support)
adc.r64.r64         rex=W opcode=0x11 modrm=reg,reg ; [AI_HINT: Tambah dengan Carry (+ + C)]
adc.r64.mem         rex=W opcode=0x13 modrm=reg,mem ; [AI_HINT: Tambah dengan Carry register dengan memori]
adc.mem.r64         rex=W opcode=0x11 modrm=mem,reg ; [AI_HINT: Tambah dengan Carry memori dengan register]
adc.r64.imm32       rex=W opcode=0x81 modrm=2 imm32 ; [AI_HINT: Tambah dengan Carry immediate 32-bit]
adc.mem.imm32       rex=W opcode=0x81 modrm=2 imm32 ; [AI_HINT: Tambah dengan Carry memori immediate 32-bit]
adc.r64.imm8        rex=W opcode=0x83 modrm=2 imm8  ; [AI_HINT: Tambah dengan Carry immediate 8-bit]
adc.mem.imm8        rex=W opcode=0x83 modrm=2 imm8  ; [AI_HINT: Tambah dengan Carry memori immediate 8-bit]

; Subtraction
sub.r64.r64         rex=W opcode=0x29 modrm=reg,reg ; [AI_HINT: Kurang register dengan register (-)]
sub.r64.mem         rex=W opcode=0x2B modrm=reg,mem ; [AI_HINT: Kurang register dengan memori (-)]
sub.mem.r64         rex=W opcode=0x29 modrm=mem,reg ; [AI_HINT: Kurang memori dengan register (-)]
sub.r64.imm32       rex=W opcode=0x81 modrm=5 imm32 ; [AI_HINT: Kurang register dengan angka 32-bit (-)]
sub.mem.imm32       rex=W opcode=0x81 modrm=5 imm32 ; [AI_HINT: Kurang memori dengan angka 32-bit (-)]
sub.r64.imm8        rex=W opcode=0x83 modrm=5 imm8  ; [AI_HINT: Kurang register dengan angka 8-bit (-)]
sub.mem.imm8        rex=W opcode=0x83 modrm=5 imm8  ; [AI_HINT: Kurang memori dengan angka 8-bit (-)]

; Subtract with Borrow (ZFC Support)
sbb.r64.r64         rex=W opcode=0x19 modrm=reg,reg ; [AI_HINT: Kurang dengan Borrow (- - C)]
sbb.r64.mem         rex=W opcode=0x1B modrm=reg,mem ; [AI_HINT: Kurang dengan Borrow register dengan memori]
sbb.mem.r64         rex=W opcode=0x19 modrm=mem,reg ; [AI_HINT: Kurang dengan Borrow memori dengan register]
sbb.r64.imm32       rex=W opcode=0x81 modrm=3 imm32 ; [AI_HINT: Kurang dengan Borrow immediate 32-bit]
sbb.mem.imm32       rex=W opcode=0x81 modrm=3 imm32 ; [AI_HINT: Kurang dengan Borrow memori immediate 32-bit]
sbb.r64.imm8        rex=W opcode=0x83 modrm=3 imm8  ; [AI_HINT: Kurang dengan Borrow immediate 8-bit]
sbb.mem.imm8        rex=W opcode=0x83 modrm=3 imm8  ; [AI_HINT: Kurang dengan Borrow memori immediate 8-bit]

; Multiplication (Signed)
imul.r64.r64        rex=W opcode=0x0F,0xAF modrm=reg,reg ; [AI_HINT: Kali (signed) register dengan register (*)]
imul.r64.mem        rex=W opcode=0x0F,0xAF modrm=reg,mem ; [AI_HINT: Kali (signed) register dengan memori (*)]
imul.r64.imm32      rex=W opcode=0x69 modrm=reg,reg imm32 ; [AI_HINT: Kali (signed) register dengan immediate 32-bit (*)]

; Multiplication (Unsigned)
mul.r64             rex=W opcode=0xF7 modrm=4 ; [AI_HINT: Kali (unsigned) RAX dengan register (RAX * r64 -> RDX:RAX)]

; Division (Signed)
idiv.r64            rex=W opcode=0xF7 modrm=7 ; [AI_HINT: Bagi (signed) RDX:RAX dengan register (/ %)]

; Division (Unsigned)
div.r64             rex=W opcode=0xF7 modrm=6 ; [AI_HINT: Bagi (unsigned) RDX:RAX dengan register (/ %)]

; Sign Extension (ZFC Support)
cqo                 rex=W opcode=0x99 ; [AI_HINT: Sign Extend RAX ke RDX:RAX (persiapan idiv)]

; Increment
inc.r64             rex=W opcode=0xFF modrm=0 ; [AI_HINT: Tambah 1 ke register (++)]
inc.mem64           rex=W opcode=0xFF modrm=0 ; [AI_HINT: Tambah 1 ke memori (++)]

; Decrement
dec.r64             rex=W opcode=0xFF modrm=1 ; [AI_HINT: Kurang 1 dari register (--)]
dec.mem64           rex=W opcode=0xFF modrm=1 ; [AI_HINT: Kurang 1 dari memori (--)]

; Negate (Two's Complement)
neg.r64             rex=W opcode=0xF7 modrm=3 ; [AI_HINT: Negasikan nilai register ( -x )]
neg.mem64           rex=W opcode=0xF7 modrm=3 ; [AI_HINT: Negasikan nilai memori ( -x )]

; Trigonometry & Floating Point (x87 FPU) - Implicit st(0)
finit               opcode=0x9B,0xDB,0xE3 ; [AI_HINT: Inisialisasi FPU]
fld.mem64           opcode=0xDD modrm=0   ; [AI_HINT: Load double (64-bit float) dari memori ke st(0)]
fld.st0             opcode=0xD9,0xC0      ; [AI_HINT: Duplicate st(0)]
fstp.mem64          opcode=0xDD modrm=3   ; [AI_HINT: Store double ke memori dan pop st(0)]
fld1                opcode=0xD9,0xE8      ; [AI_HINT: Load konstanta 1.0 ke st(0)]
fldz                opcode=0xD9,0xEE      ; [AI_HINT: Load konstanta 0.0 ke st(0)]
fldpi               opcode=0xD9,0xEB      ; [AI_HINT: Load konstanta PI ke st(0)]
fadd.mem64          opcode=0xDC modrm=0   ; [AI_HINT: Tambah st(0) dengan memori]
fsub.mem64          opcode=0xDC modrm=4   ; [AI_HINT: Kurang st(0) dengan memori]
fmul.mem64          opcode=0xDC modrm=1   ; [AI_HINT: Kali st(0) dengan memori]
fdiv.mem64          opcode=0xDC modrm=6   ; [AI_HINT: Bagi st(0) dengan memori]
faddp               opcode=0xDE,0xC1      ; [AI_HINT: Tambah st(1) = st(1) + st(0), pop]
fsubp               opcode=0xDE,0xE9      ; [AI_HINT: Kurang st(1) = st(1) - st(0), pop]
fmulp               opcode=0xDE,0xC9      ; [AI_HINT: Kali st(1) = st(1) * st(0), pop]
fdivp               opcode=0xDE,0xF9      ; [AI_HINT: Bagi st(1) = st(1) / st(0), pop]
fsin                opcode=0xD9,0xFE      ; [AI_HINT: Hitung Sinus dari st(0) -> st(0)]
fcos                opcode=0xD9,0xFF      ; [AI_HINT: Hitung Cosinus dari st(0) -> st(0)]
fptan               opcode=0xD9,0xF2      ; [AI_HINT: Hitung Tangent dari st(0) -> st(1):st(0) (1.0 : tan)]
fsqrt               opcode=0xD9,0xFA      ; [AI_HINT: Hitung Akar Kuadrat dari st(0)]

; Modern SSE/AVX (Single Precision - XMM)
; Note: We use .xmm suffix for type safety
movss.xmm.mem       opcode=0xF3,0x0F,0x10 modrm=reg,mem ; [AI_HINT: Load float 32-bit dari mem ke XMM]
movss.mem.xmm       opcode=0xF3,0x0F,0x11 modrm=mem,reg ; [AI_HINT: Store float 32-bit dari XMM ke mem]
movss.xmm.xmm       opcode=0xF3,0x0F,0x10 modrm=dst_reg,src_reg ; [AI_HINT: Move float 32-bit antar XMM]
addss.xmm.xmm       opcode=0xF3,0x0F,0x58 modrm=dst_reg,src_reg ; [AI_HINT: Add float (xmm1 += xmm2)]
addss.xmm.mem       opcode=0xF3,0x0F,0x58 modrm=reg,mem         ; [AI_HINT: Add float mem to xmm]
subss.xmm.xmm       opcode=0xF3,0x0F,0x5C modrm=dst_reg,src_reg ; [AI_HINT: Sub float]
mulss.xmm.xmm       opcode=0xF3,0x0F,0x59 modrm=dst_reg,src_reg ; [AI_HINT: Mul float]
divss.xmm.xmm       opcode=0xF3,0x0F,0x5E modrm=dst_reg,src_reg ; [AI_HINT: Div float]
ucomiss.xmm.xmm     opcode=0x0F,0x2E modrm=dst_reg,src_reg      ; [AI_HINT: Compare float unordered]
cvtsi2ss.xmm.r64    rex=W opcode=0xF3,0x0F,0x2A modrm=dst_reg,src_reg ; [AI_HINT: Convert Int64 to Float32]
cvtss2si.r64.xmm    rex=W opcode=0xF3,0x0F,0x2D modrm=dst_reg,src_reg ; [AI_HINT: Convert Float32 to Int64 (Round)]
cvttss2si.r64.xmm   rex=W opcode=0xF3,0x0F,0x2C modrm=dst_reg,src_reg ; [AI_HINT: Convert Float32 to Int64 (Truncate)]
